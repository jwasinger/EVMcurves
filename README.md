This is an experiment to implement the BLS12-381 pairing operation in EVM with the proposed EVM384 extension.


## Files

```
genhuff.py		includes all cryptography, based off the blst algorithms, outputs huff file miller_loop.huff

miller_loop.huff	huff source for the miller loop test, generated by genhuff.py
main.huff		huff source which sets up memory and starts the miller loop
miller_loop.hex		EVM bytecode output by huff from main.huff

compile.js              calls the huff compiler on main.huff
huff.patch              patch to tell huff how to handle evm384 opcodes
```

## Generate

Get these files.

```
git clone https://github.com/poemm/EVMcurves
cd evmcurves
```

Get huff. Note: we put huff inside directory `EVMcurves/` because the path to huff is hardcoded in `compile.js`.

```
git clone https://github.com/AztecProtocol/huff.git
```

Patch huff with new EVM384 opcodes.

```
#diff -ruN huff huff_modified > huff.patch
patch -s -p0 < huff.patch
```

Get dependencies listed in `huff/package.json`. (Don't worry, everything is local to the created dir `node_modules/`, can just delete that dir.)

```
cd huff
npm install	# note: npm caches packages in /home/<user>/.npm. To remove cache: npm cache clean
cd ..
```

Finally generate the EVM bytecode for the Miller loop.

```
python3 genhuff.py > miller_loop.huff
node compile.js > miller_loop.hex
```

## Execute

To execute the generated EVM bytecode, one needs an EVM implementation with the EVM384 extension. Here is one for [evmone](https://github.com/jwasinger/evmone/tree/evm384-v7). Note: currently we generate EVM384v7 bytecode.


## TODO

- Different f2mul algorithms give different outputs. This is a known property of BLS12-381 pairings -- the intermediate/output values need not be the same across different implementations. We found that the values diverge from blst at f2mul, and remain the same otherwise. We use a standard algorithm for f2mul, but we have yet to confirm that bilinearity holds with this standard f2mul.
- Final exponentiation is mostly done and tested except the following. (1) The output is very large, so we are working on wrapping `f12mul` and `f12sqrcyclotomic` to appear only once, with jumps to/from them, which takes some work to figure out how to do without much of a slowdown. (2) An inversemod384 is needed -- there are many options for this, the easiest is using the modexp precompile.
- Subgroup checks.
- Elliptic curve point addition and scalar multiplication. Challenges include getting out of Jacobian form. Scalar multiplication has many possible optimizations, but we will start with the simplest double & add loop.
- Hash to curve.


