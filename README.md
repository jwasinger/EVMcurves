#EVMCurves

This is an experiment to implement the BLS12-381 pairing operation in EVM with the proposed EVM384 extension (three new opcodes: `ADDMOD384`, `SUBMOD384`, `MULMODMONT384`). Feedback and discussion occurs on Ethereum allcoredevs chat, allcoredevs calls, and on [this discussion thread](https://ethereum-magicians.org/t/evm384-feedback-and-discussion/4533).


Cryptography is implemented in a python generator (`genhuff.py`) which produces a [Huff](https://github.com/aztecprotocol/huff) module for BLS12381 operations in EVM384 (`bls12_381.huff`).

## Files

```
genhuff.py		 includes all cryptography, based off the blst algorithms, outputs huff file

bls12_381.huff		 various huff modules generated by genhuff.py
main.huff		 huff file which selects which modules in BLS12_381.huff to assemble with huff, plus some basic memory setup and i/o
miller_loop.hex		 EVM bytecode generated from main.huff module MILLER_LOOP_TEST_HARD_CODED
inversemod_bls12381.huff included in bls12_381.huff, implements field inversemod with respect to the BLS12-381 prime; to generate this file: https://gist.github.com/poemm/52653a344528278f09403354569d0855

compile.js              compiles main.huff to EVM384
```


## Usage 

Install dependencies
```
git submodule update --init --recursive
(cd evmone && mkdir build && cmake -DEVMONE_TESTING=ON .. && make)

# build evm bytecode for miller loop / final exp tests
make build

# test them with evmone-bench
make test
```

## TODO

- BLS12-381
  - `PAIRING_EQ2_TEST` is untested, just for measuring two miller loops, a f12mul, a final exponentiation, and a f12 equality check.
  - Subgroup checks.
  - ECmul and ECadd. Challenges include getting out of Jacobian form. Scalar multiplication has many possible optimizations, but we will start with the simplest double & add loop.
  - Hash to curve.
- Other pairings, e.g. BN128 and BLS12-377
- ECDSA e.g. secp256k1
- Algebraic hashing e.g. Petersen hashing 
- STARK verification e.g. polynomial evaluation
- Other crypto

